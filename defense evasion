artifact kit:
  cobalt strike (CS) client is packaged with default executable templates (exe, svc.exe, dll)
    noted 32 or 64 to specify arch
    'big' appended to note stagless payloads
    svc are the service binary templates
  CS then uses these template to generate the user defined shellcode
  because these templates are the same across all CS deployments, they are often targeted by AV
  we can alter these templates via the artifact kit to bypass AV
  we can build new templates using ./build.sh included in the artifact kit
    ex.  ./build.sh <techniques> <allocator> <stage size> <rdll size> <include rsc file> <stack spoof> <syscalls> <output dir>
    e.g. ./build.sh mailslot VirtualAlloc 344564 0 false false none /mnt/c/Tools/cobaltstrike/custom-artifacts
  NOTE: use https://github.com/rasta-mouse/ThreatCheck to analyze if binary comes back as malicious
        if any section comes back as malicious, check ghidra to find the exact line of code and modify it
  once we have our new templates, load them via CS > Script Manager > Load

resource kit:
  CS also has templates for script-based payloads, such as PowerShell
    NOTE: generating the new resource templates only requires an output dir
    e.g. mnt/c/Tools/cobaltstrike/arsenal-kit/kits/resource$ ./build.sh /mnt/c/Tools/cobaltstrike/custom-resources
  Windows AntiMalware Scan Interface (AMSI) is a concern here as it detects malware running in memory
    NOTE: AMSI submits data to an AV for analysis and the AV determines if the data is malicious
  native Windows components that are AMSI aware include UAC, PowerShell, Windows Script Host, JavaScript, VBScript, VBA macros
  the best approach is to find the malicious parts and change them, as attempts to fool AMSI will likely be detected
  use the same ThreatCheck tool to find the malicious parts and then alter using least-complex to most-complex
    e.g. if ThreatCheck flags "('System.dll')" then change it to "('Syst'+'em.dll')"
    e.g. if Marshal.Copy is flagged switch to WriteProcessMemory API call
  NOTE: if we host a payload using the scripted web delivery, it may be detected due to compress.ps1
        if this happens, we can use https://github.com/danielbohannon/Invoke-Obfuscation and replace the content of compress.ps1

beacon memory:
  all these artifacts do the same thing: inject beacon shellcode and then the beacon runs in memory
  some AV can detect these beacons via memory scanning capabilities
  RWX memory:
    most applications do not use RWX memory so it can be a red flag for AV
    to avoid this, set stage.userwx to false in Malleable C2
  DLL headers:
    when the beacon is loaded into memory, it includes the PE headers which makes it obvious a PE is running
    to avoid this, set stage.copy_pe_header to false
  module stomping:
    memory sections of a loaded PE are typically backed by a module on disk (b/c that's where they were loaded from)
    the beacon PE would have no module backing it as it was loaded from memory, which could be a red flag to an AV
    to avoid this, use stage.module_x64 (e.g. set stage.module_x64 "Hydrogen.dll") 
      NOTE: ensure you select a PE that is at least 512KB

strings:
  hardcoded strings in the .rdata and .text sections can trigger memory-based detections
  we can use BEACON_RDLL_GENERATE to get a raw DLL so we can search for strings (https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics_aggressor-scripts/as-resources_hooks.htm#BEACON_RDLL_GENERATE)
  then running "strings -d beacon_raw.x64.dll" will likely output format strings related to beacon output
  to avoid this, we can replace these strings within the Malleable C2 profile using stage.transform-x64 and strrep
    NOTE: when using strrep, the new string must be short or equal to original length, and we must keep the format strings valid (e.g. %s for strings)
example of stage within Malleable C2...
  stage {
      set userwx "false";
      set cleanup "true";
      set copy_pe_header "false";
      set module_x64 "Hydrogen.dll";
      
      transform-x64 {
          strrep "beacon.x64.dll" "bacon.x64.dll";
          strrep "%02d/%02d/%02d" "%02d/%02d/%04d";
          strrep "%s as %s\\\\%s: %d" "%s - %s\\\\%s: %d";
          strrep "%02d/%02d/%02d %02d:%02d:%02d" "%02d-%02d-%02d %02d:%02d:%02d";
          strrep "\\x48\\x89\\x5C\\x24\\x08\\x57\\x48\\x83\\xEC\\x20\\x48\\x8B\\x59\\x10\\x48\\x8B\\xF9\\x48\\x8B\\x49\\x08\\xFF\\x17\\x33\\xD2\\x41\\xB8\\x00\\x80\\x00\\x00" "\\x48\\x89\\x5C\\x24\\x08\\x57\\x48\\x83\\xEC\\x20\\x48\\x8B\\x59\\x10\\x48\\x8B\\xF9\\x48\\x8B\\x49\\x08\\xFF\\x17\\x33\\xD2\\x41\\xB8\\x01\\x80\\x00\\x00";
      }
  }

beacon command overview & behavior:
  https://www.zeropointsecurity.co.uk/path-player?courseid=red-team-ops&unit=696a1d7abd92eef9e30f7537Unit
